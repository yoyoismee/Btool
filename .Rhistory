#     test_stations(knn.wrapper, preselected_stations = TRUE)
test_stations <- function(predict_function, stations = station,
preselected_stations = TRUE,
directory = "data/CFSRR_byStationV2/",
station.list.filename = "data/TMD/TMD_rainfall_station.csv",
lifesign.stations = TRUE,
print.results = FALSE,
...){
station <- read.csv(station.list.filename)
stations <- station$code_update
if(preselected_stations == TRUE){
stations <- c(300201,327501,405201,356201,
455201,429201,480301,459202,
450201,376201,564202,552201)
}
all.results <- data.frame()
for(i in 1:length(stations)){
s <- stations[i]
if(lifesign.stations == TRUE){
print(paste(i, s))
}
filename <- paste(directory, s, ".csv", sep="")
if(!file.exists(filename)){
if(lifesign.stations == TRUE){
print("file not existed.")
}
next
}
rain <- read.csv(filename)
rain <- na.omit(rain)
result <- mean_result(k_fold_test(rain, rain$rainfall, predict_function, ...))
result$station <- s
if(print.results){
print(result$station)
}
all.results <- rbind(all.results, result)
}
all.results <- all.results[, c(ncol(all.results), 1:(ncol(all.results) - 1))]
all.results
}
allres <- test_stations(fitSVM,lifesign.stations = TRUE)
#
# test_stations function
#
#    3-fold test the given stations with the given predict function
#
# input: - predict_function - a function that predicts the result
#                    must be in this format:
#                       input: train and test data frames
#                       output: a vector containing predicted values
#        - stations - a vector containing station code to be tested
#        - preselected_stations - when set TRUE, it will test only the pre selected stations
#        - directory - string of file path containing the rain data
#        - station.list.filename - file path of csv file containing list of stations in column code_update
#        - lifesign.station - if TRUE, the function will print progress on each station
#        - print.results - if TRUE, the function will print result of each station while running
#
# output: a data frame containing mean of evaluator values in each station
#
# example:
#     test_stations(knn.wrapper, preselected_stations = TRUE)
test_stations <- function(predict_function, stations = station,
preselected_stations = TRUE,
directory = "desktop/HAII/byStationV2/",
station.list.filename = "desktop/HAII/byStationV2/TMD_rainfall_station.csv",
lifesign.stations = TRUE,
print.results = FALSE,
...){
station <- read.csv(station.list.filename)
stations <- station$code_update
if(preselected_stations == TRUE){
stations <- c(300201,327501,405201,356201,
455201,429201,480301,459202,
450201,376201,564202,552201)
}
all.results <- data.frame()
for(i in 1:length(stations)){
s <- stations[i]
if(lifesign.stations == TRUE){
print(paste(i, s))
}
filename <- paste(directory, s, ".csv", sep="")
if(!file.exists(filename)){
if(lifesign.stations == TRUE){
print("file not existed.")
}
next
}
rain <- read.csv(filename)
rain <- na.omit(rain)
result <- mean_result(k_fold_test(rain, rain$rainfall, predict_function, ...))
result$station <- s
if(print.results){
print(result$station)
}
all.results <- rbind(all.results, result)
}
all.results <- all.results[, c(ncol(all.results), 1:(ncol(all.results) - 1))]
all.results
}
allres <- test_stations(fitSVM,lifesign.stations = TRUE)
# View(allres)
# write.csv(allres, "results/2015-11-03/knn_weighted_collapsed.csv")
getwd()
rain <- read.csv("desktop/HAII/byStationV2/")
rain <- read.csv("desktop/HAII/byStationV2/300201.csv")
#
# test_stations function
#
#    3-fold test the given stations with the given predict function
#
# input: - predict_function - a function that predicts the result
#                    must be in this format:
#                       input: train and test data frames
#                       output: a vector containing predicted values
#        - stations - a vector containing station code to be tested
#        - preselected_stations - when set TRUE, it will test only the pre selected stations
#        - directory - string of file path containing the rain data
#        - station.list.filename - file path of csv file containing list of stations in column code_update
#        - lifesign.station - if TRUE, the function will print progress on each station
#        - print.results - if TRUE, the function will print result of each station while running
#
# output: a data frame containing mean of evaluator values in each station
#
# example:
#     test_stations(knn.wrapper, preselected_stations = TRUE)
test_stations <- function(predict_function, stations = station,
preselected_stations = TRUE,
directory = "desktop/HAII/byStationV2/",
station.list.filename = "desktop/HAII/byStationV2/TMD_rainfall_station_20140411.csv",
lifesign.stations = TRUE,
print.results = FALSE,
...){
station <- read.csv(station.list.filename)
stations <- station$code_update
if(preselected_stations == TRUE){
stations <- c(300201,327501,405201,356201,
455201,429201,480301,459202,
450201,376201,564202,552201)
}
all.results <- data.frame()
for(i in 1:length(stations)){
s <- stations[i]
if(lifesign.stations == TRUE){
print(paste(i, s))
}
filename <- paste(directory, s, ".csv", sep="")
if(!file.exists(filename)){
if(lifesign.stations == TRUE){
print("file not existed.")
}
next
}
rain <- read.csv(filename)
rain <- na.omit(rain)
result <- mean_result(k_fold_test(rain, rain$rainfall, predict_function, ...))
result$station <- s
if(print.results){
print(result$station)
}
all.results <- rbind(all.results, result)
}
all.results <- all.results[, c(ncol(all.results), 1:(ncol(all.results) - 1))]
all.results
}
allres <- test_stations(fitSVM,lifesign.stations = TRUE)
# View(allres)
# write.csv(allres, "results/2015-11-03/knn_weighted_collapsed.csv")
#
# test_stations function
#
#    3-fold test the given stations with the given predict function
#
# input: - predict_function - a function that predicts the result
#                    must be in this format:
#                       input: train and test data frames
#                       output: a vector containing predicted values
#        - stations - a vector containing station code to be tested
#        - preselected_stations - when set TRUE, it will test only the pre selected stations
#        - directory - string of file path containing the rain data
#        - station.list.filename - file path of csv file containing list of stations in column code_update
#        - lifesign.station - if TRUE, the function will print progress on each station
#        - print.results - if TRUE, the function will print result of each station while running
#
# output: a data frame containing mean of evaluator values in each station
#
# example:
#     test_stations(knn.wrapper, preselected_stations = TRUE)
test_stations <- function(predict_function, stations = station,
preselected_stations = TRUE,
directory = "desktop/HAII/byStationV2/",
station.list.filename = "desktop/HAII/byStationV2/TMD_rainfall_station_20140411.csv",
lifesign.stations = TRUE,
print.results = FALSE,
...){
station <- read.csv(station.list.filename)
stations <- station$code_update
if(preselected_stations == TRUE){
stations <- c(300201,327501,405201,356201,
455201,429201,480301,459202,
450201,376201,564202,552201)
}
all.results <- data.frame()
for(i in 1:length(stations)){
s <- stations[i]
if(lifesign.stations == TRUE){
print(paste(i, s))
}
filename <- paste(directory, s, ".csv", sep="")
if(!file.exists(filename)){
if(lifesign.stations == TRUE){
print("file not existed.")
}
next
}
rain <- read.csv(filename)
rain <- na.omit(rain)
result <- mean_result(k_fold_test_sta(rain, rain$rainfall, predict_function, ...))
result$station <- s
if(print.results){
print(result$station)
}
all.results <- rbind(all.results, result)
}
all.results <- all.results[, c(ncol(all.results), 1:(ncol(all.results) - 1))]
all.results
}
allres <- test_stations(fitSVM,lifesign.stations = TRUE)
#
# test_stations function
#
#    3-fold test the given stations with the given predict function
#
# input: - predict_function - a function that predicts the result
#                    must be in this format:
#                       input: train and test data frames
#                       output: a vector containing predicted values
#        - stations - a vector containing station code to be tested
#        - preselected_stations - when set TRUE, it will test only the pre selected stations
#        - directory - string of file path containing the rain data
#        - station.list.filename - file path of csv file containing list of stations in column code_update
#        - lifesign.station - if TRUE, the function will print progress on each station
#        - print.results - if TRUE, the function will print result of each station while running
#
# output: a data frame containing mean of evaluator values in each station
#
# example:
#     test_stations(knn.wrapper, preselected_stations = TRUE)
test_stations <- function(predict_function, stations = station,
preselected_stations = TRUE,
directory = "desktop/HAII/byStationV2/",
station.list.filename = "desktop/HAII/byStationV2/TMD_rainfall_station_20140411.csv",
lifesign.stations = TRUE,
print.results = FALSE,
...){
station <- read.csv(station.list.filename)
stations <- station$code_update
if(preselected_stations == TRUE){
stations <- c(300201,327501,405201,356201,
455201,429201,480301,459202,
450201,376201,564202,552201)
}
all.results <- data.frame()
for(i in 1:length(stations)){
s <- stations[i]
if(lifesign.stations == TRUE){
print(paste(i, s))
}
filename <- paste(directory, s, ".csv", sep="")
if(!file.exists(filename)){
if(lifesign.stations == TRUE){
print("file not existed.")
}
next
}
rain <- read.csv(filename)
rain <- na.omit(rain)
result <- mean_result(k_fold_test_sta(rain, rain$rainfall, predict_function, ...))
result$station <- s
if(print.results){
print(result$station)
}
all.results <- rbind(all.results, result)
}
all.results <- all.results[, c(ncol(all.results), 1:(ncol(all.results) - 1))]
all.results
}
allres <- test_stations(fitSVM,lifesign.stations = TRUE)
# View(allres)
# write.csv(allres, "results/2015-11-03/knn_weighted_collapsed.csv")
View(allres)
write.csv(allres,"desktop/HAII/SVM-KNN.csv")
order(c(0,1,1,1,2,3))
?cor
demo()
demo(sd)
demo(sd())
order(c(1,3,4,2,5,7))
order(c(1,3,4,2,5,7))[1]
order(c(10,3,4,2,5,7))[1]
order(c(10,3,4,2,5,7))
order(c(10,3,4,2,5,7))
order(c(10:1)
)
order(c(1,2,3))
order(c(1,3,2))
order(c(2,3,1))
order(c(2,3,1))
order(c(1,2,3))
order(c(2,3,1))
order(c(2,3))
order(c(2,3,1))
order(c(2,3,1,0))
order(c(4,3,1,0))
order(c(2,3,1,0))
F1<-data.frame(K=1:300)
x<-data.frame(1:100,2:101,3:102)
x[x[,2]>50,]
x[x[,2]>=50,]
x[x[,3]>=50,]
F1[x[,3]>=50,]
F1[x[,3]<50,]
x[x[,3]<50&x[,1]>30,]
x[x[,3]<50&&x[,1]>30,]
library(FNN)
install.packages(FNN)
install.packages(FNN)
install.packages("FNN")
?knn.reg
?knn
?"knn.reg"
?"knn"
?"fnn"
?"FNN"
help(knn.reg)
x[1:10]
x[1:10,]
x[order(x$X1.100,decreasing = TRUE),]
pred<-vector()
pred[1]<-1
pred[2]<-13
pred<-vector()
#
# eval function
#
#    evaluate forecast/predicted data according to actual data
#
# input: actual (vector) - real values to be compared
#        forecast (vector) - predicted values
#        criteria - data will be considered 'positive' if it is
#                   more than or equal this criteria, default is 1
#        categories - break points to classify the results
#
# output: evaluator values, namely,
#         - percentage of true/false positives/negatives (0 to 1)
#         - accuracy, precision, recall and F1 score
#         - MAE of real negatives and real positives
#         - MAPE of real positives
#
# notes: - size of actual and forecast vectors must be equal.
#
evaluate <- function(actual, forecast, criteria = 0.1){
#categories = c(0.1, 10, 35, 90)){
result <- data.frame(actual, forecast)
n <- nrow(result)
true_positive <- nrow(result[actual >= criteria & forecast >= criteria, ]) / n
true_negative <- nrow(result[actual < criteria & forecast < criteria, ]) / n
false_positive <- nrow(result[actual < criteria & forecast >= criteria, ]) / n
false_negative <- nrow(result[actual >= criteria & forecast < criteria, ]) / n
accuracy <- (true_positive + true_negative)
precision <- true_positive / (true_positive + false_positive)
recall <- true_positive / (true_positive + false_negative)
f1_score <- 2 * precision * recall / (precision + recall)
negative <- result[actual < criteria, ]
mae_negative <- mean(abs(negative$actual - negative$forecast))
positive <- result[actual >= criteria, ]
mae_positive <- mean(abs(positive$actual - positive$forecast))
mape_positive <- mean(abs(positive$actual - positive$forecast)/positive$actual)
rmse <- sqrt(mean((actual - forecast)^2))
rmse_negative <- sqrt(mean((negative$actual - negative$forecast)^2))
rmse_positive <- sqrt(mean((positive$actual - positive$forecast)^2))
# Eval #3: RMSE by each ranges
# r_cat <- result[result$actual <= catagories[1],]
# rmse_cat <- sqrt(mean((r_cat$actual - r_cat$forecast)^2))
# for(i in 1:(length(categories) - 1)){
#   r_cat <- result[catagories[i] <= result$actual & result$actual <= catagories[i+1],]
#   rmse_cat <- c(rmse_cat, sqrt(mean((r_cat$actual - r_cat$forecast)^2)))
# }
# r_cat <- result[result$actual <= catagories[length(categories)],]
# rmse_cat <- c(rmse_cat, sqrt(mean((r_cat$actual - r_cat$forecast)^2)))
# UNFINISHED: needs a way to send vector into list that is bindable to data frame
list(true_positive = true_positive,
true_negative = true_negative,
false_positive = false_positive,
false_negative = false_negative,
accuracy = accuracy,
precision = precision,
recall = recall,
f1_score = f1_score,
rmse = rmse,
rmse_negative = rmse_negative,
rmse_positive = rmse_positive)
# mae_negative = mae_negative,
# mae_positive = mae_positive,
# mape_positive = mape_positive
# r_cat = r_cat)
}
mean_result <- function(result){
list(true_positive = mean(result$true_positive),
true_negative = mean(result$true_negative),
false_positive = mean(result$false_positive),
false_negative = mean(result$false_negative),
accuracy = mean(result$accuracy),
precision = mean(result$precision),
recall = mean(result$recall),
f1_score = mean(result$f1_score),
rmse = mean(result$rmse),
rmse_positive = mean(result$rmse_positive),
rmse_negative = mean(result$rmse_negative))
}
# example:
#
# actual <- c(0,0,0,0,1,1,1,1)
# predicted <- c(0,0,1,0,1,1,0,0)
#
# eval(actual, predicted, criteria = 0.5)
nrow(1:10)
ncol(1:10)
n(1:10)
count.fields(1:10)
length(1:10)
x=null
x=NULL
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# usage
baseLib <- c("xlsx", "rJava")
visualizeLib <- c("Hmisc", "scatterplot3d")
classificationLib <- c("party", "e1071", "class", "FNN", "knncat", "ggplot2", "partykit")
armLib <-c("arules", "arulesViz", "datasets")
sentimentLib <- c("httr", "jsonlite", "plyr", "ggplot2", "stringr")
ipak(baseLib)
ipak(visualizeLib)
ipak(classificationLib)
ipak(armLib)
ipak(sentimentLib)
install.packages("igraph")
xx <- readLines(stdin(),1)
xx <- readLines(stdin())
system()
system.info()
Sys.info()
Sys.setenv()
Sys.info()
remove.packages("random")
if(!require(random)){
install.packages("random")
require(random)
}
randomStrings()
install.packages(random)
install.packages("random")
install.packages("random")
install.packages("random")
library(random)
randomStrings()
remove.packages("random")
install.packages("random")
install.packages("random")
random::quotaCheck()
system("locate libSM.6.dylib")
library(random)
randomNumbers()
randomStrings()
?cat
cat(file = "stdout","asdasd")
getwd()
search()
library(random)
search()
library(parallel)
search()
.onLoad()
requireNamespace()
requireNamespace()
?requireNamespace
?commandArgs
file("asas")
getwd()
list.files()
?file
setwd(dir = "Desktop/Btool/")
inputSource<- file("input.txt")
inputSource
readline(inputSource)
readline(inputSource,1)
readlines(inputSource,1)
readLines(inputSource,1)
readLines(inputSource,1)
readLines(inputSource,1)
inputSource<- file("input.txt",blocking = T)
readLines(inputSource,1)
readLines(inputSource,1)
inputSource<- file("input.txt",blocking = T,open = T)
inputSource<- file("input.txt",blocking = T,open = "r")
readLines(inputSource,1)
readLines(inputSource,1)
inputSource
